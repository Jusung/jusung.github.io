---
layout: post
title: "[책 소개] 토미의 Git with 소스트리"
category:
  - 토미의 Git
tag:
  - 책소개
comments: true
published: true
---

# (center aligned 된 책 이미지  첨부)

![]({{ site.baseurl }}/images/2018/Swift Official Document Translation.jpg)

이 페이지에서 토미의 Git with 소스트리 책을 미리 볼 수 있습니다.

미리보기에 포함돼 있는 내용은 다음과 같습니다.

## 1. 미리보기에 포함돼 있는 내용

- 저자의 글
- 이 책의 대상 독자
- 이 책을 읽는 법
- 감사의 글
- 목차
- 샘플 챕터 : 10. 리베이스 (Rebase)

## 2. 책을 미리보는 세 가지 방법

2. 아래에 첨부 돼 있는 PDF를 직접 보기

## 3. 책 구매 링크

책은 종이책과 전자책 모두 제공 합니다. 종류별 구매 링크는 다음과 같습니다.

1. 종이책 구매 링크
   - YES24:
   - 교보:
   - 알라딘:
2. 전자책 구매 링크
   - YES24:
   - 교보:
   - 알라딘:

## 4. 샘플 챕터 : 10. 리베이스 (Rebase)

## 10. 리베이스 (Rebase)

“토미~ 안녕하세요?”

“네~ 안녕하세요?”

“다음 배포 때, 그동안 개발했던 자율주행 이동 수단을 포함해 나갈 수 있을까요?”

“자율주행 이동 수단이라면 택시, 버스, 배, 비행기, 자전거 말씀하시는 거죠?”

“네 맞아요. 모든 이동 수단을 사용할 수 있도록 서비스에 반영하고 싶어요. 가능할까요?”

“네~ 물론이죠.”

토미는 이동 수단별로 각기 다른 브랜치에서 개발했기 때문에 배포시 필요에 따라 모든 기능 을 포함시키거나 일부만 포함시킬 수 있었습니다.
‘자~ 그럼 각 기능 브랜치를 배포할 브랜치에 머지 해볼까?’

‘짜잔~ 머지 완료! 이렇게 배포할 브랜치에 머지가 끝났으니 배포 준비 완료됐네?’

‘역시! 나 토미야! ᄏ’

토미는 스스로 대견해하며 만족스러운 미소를 띠었습니다. 하지만 이내 한 가지가 눈에 들어 왔습니다.

‘가만있자! 이거 기능적으로는 문제가 없는데, 여러 브랜치가 하나의 브랜치에 머지되니 히 스토리가 복잡해 보이네. 이걸 개선할 수 있는 방법은 없을까?’

토미는 성공적으로 각 기능을 배포 브랜치에 머지 했지만, 머지된 후 Git의 커밋 히스토리가 마음에 들지 않았습니다.

‘아... 이거 보면 볼수록 복잡해 보인다. 정리하고 싶은데, 이것도 무슨 방법이 있겠지? 어떤 방법이 있는지 한번 알아봐야겠다.’

### 10.1 개요

챕터 8에서 브랜치를 합치는 방법 중 하나인 머지에 대해 살펴보았습니다. 때때로 브랜치를 합칠 때 머지대신 다른 방법을 사용해야할 때가 있습니다. 이번 챕터에서는 리베이스에 대 해 살펴보겠습니다. 앞에서 토미가 겪었던 상황을 예를들어 보겠습니다.

아래 [그림 10-1]과 같이 머지 시킬 브랜치(develop)와 이 브랜치에 여러 기능을 포함시키 기 위해 머지할 FeatureA, FeatureB, FeatureC 세 개의 브랜치가 있습니다.![]({{ site.baseurl }}/images/GitBook/Branch Rebase01.pdf){: .width="500px" height="500px" .center-image}
*[그림 10-1] develop에 머지 할 세개의 Feature 브랜치*
{: style="text-align: center;"}

FeatureA, FeatureB, FeatureC 브랜치를 각각 순서대로 develop 브랜치에 머지시키면 Git 의 커밋 히스토리는 [그림 10-2]와 같은 모습이 됩니다.

![]({{ site.baseurl }}/images/GitBook/Branch Rebase02.pdf){: .width="500px" height="500px" .center-image}
*[그림 10-2] develop에 세 개의 Feature 브랜치를 머지한 후 커밋 히스토리*
{: style="text-align: center;"}

develop 브랜치에는 FeatureA, FeatureB, FeatureC 각 브랜치의 변경사항이 반영된 상태 입니다. 그래서 기능상으로는 문제가 없습니다. 하지만 히스토리가 조금 복잡해 보입니다. 만약 develop에 머지된 브랜치가 3개가 아니라 5개 혹은 10개라면 히스토리는 훨씬 더 복 잡하게 보일 것입니다.

이런 상황에서 머지대신 리베이스를 사용하면 아래 [그림 10-3]과 같이 브랜치를 머지커밋 생성없이 일렬로 된 형태로 브랜치를 합칠 수 있어서 Git의 커밋 히스토리를 간결하게 관리 할 수 있습니다.

![]({{ site.baseurl }}/images/GitBook/Branch Rebase03.pdf){: .width="500px" height="500px" .center-image}
*[그림 10-3] 세 개의 Feature 브랜치를 develop 브랜치에 리베이스로 반영 후 커밋 히스토리*
{: style="text-align: center;"}

이번 챕터에서는 이 리베이스에 대해 알아 보겠습니다.

### 10.2 리베이스란?

일반적으로 브랜치는 브랜치의 시작점이 되는 base(부모)가 존재 합니다. 리베이스는 브랜 치의 base를 변경해 브랜치를 합치는 방법입니다.

![]({{ site.baseurl }}/images/GitBook/Branch Rebase04.pdf){: .width="500px" height="500px" .center-image}
*[그림 10-4] 리베이스 전/후 커밋 히스토리*
{: style="text-align: center;"}

위 [그림 10-4]의 왼쪽 리베이스 전 그림에서 Feature 브랜치의 base는 C1 커밋입니다. Feature를 develop와 합치기 위해 리베이스를 수행합니다. 리베이스를 하면 [그림 10-5]의 오른쪽 그림 같이 Feature의 base가 C1에서 C7로 변경되고 두 브랜치가 일렬로된 형태로 합쳐집니다.

### 10.3 리베이스의 동작

리베이스를 수행하면 내부적으로는 각 커밋별로 패치를 생성해 순서대로 다른 브랜치에 적 용합니다. 리베이스 후 마치 커밋이 원본 브랜치에서 다른 브랜치로 base만 바뀌어서 이동 한 것 처럼 보지만만 실제로는 같은 메시지와 변경사항을 포함한 새로운 커밋이 생성돼 재적 용된 것입니다.

![]({{ site.baseurl }}/images/GitBook/Branch Rebase05.pdf){: .width="500px" height="500px" .center-image}
*[그림 10-5] 리베이스의 동작 과정*
{: style="text-align: center;"}

위 [그림 10-5]는 Feature 브랜치를 develop 에 리베이스하는 과정입니다. Feature 브랜치 를 develop에 리베이스 해서 C2, C3, C4 커밋이 develop 에 적용됐습니다. 여기서 주의깊 게 보실 것은 C2, C3, C4 커밋이 develop에 그대로 옮겨진 것이 아니라 각각 C2’, C3’, C4’ 로 변경됐다는 것입니다.

앞서 설명드린바와 같이 리베이스를 수행하면 커밋이 그대로 이동하는 것이 아니라 새로 생 성됩니다. 그렇기 때문에 리베이스로 생성된 커밋은 원본 커밋과 해시가 다른 커밋이 됩니 다. 커밋의 해시가 다르기 때문에 Git이 봤을때 C2, C3, C4는 C2’, C3’, C4’와 각각 다른 커밋 입니다. 커밋을 새로 생성하면 왜 다른 커밋이 되는걸까요? 커밋 메시지나, 커밋 작성자 등 정보는 동일한데 말이죠?

앞의 챕터3.6에서 커밋의 아이디인 SHA-1가 어떻게 만들어지는지 살펴봤었습니다. Git은 커밋을 SHA-1로 구분하는데 커밋의 SHA-1을 생성하는데 사용하는 요소에 커밋 생성 시간 과 부모 커밋이 포함된다고 말씀드렸습니다. 위 [그림 10-5] 에서는 리베이스를 수행 해서 커밋이 재생성됐는데 커밋을 재생성 했기 때문에 커밋 생성시간이 변경 되었고, base가 변 경 됐기 때문에 C2, C3, C4 커밋의 부모 커밋도 각각 C1, C2, C3에서 C7, C2’, C3’ 으로